import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_quill/quill_delta.dart';
import 'package:my_manga_editor/common/logger.dart';
import 'package:my_manga_editor/feature/manga/model/manga.dart';
import 'package:my_manga_editor/feature/manga/model/sync_status.dart';
import 'package:my_manga_editor/feature/manga/repository/delta_cache.dart';
import 'package:my_manga_editor/feature/manga/repository/exceptions.dart'
    as repo_exceptions;
import 'package:my_manga_editor/service/firebase/auth_service.dart';
import 'package:my_manga_editor/service/firebase/firebase_service.dart';
import 'package:my_manga_editor/service/firebase/model/cloud_manga.dart';
import 'package:my_manga_editor/service/firebase/model/cloud_manga_page.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'manga_repository.g.dart';

@Riverpod(keepAlive: true)
MangaRepository mangaRepository(Ref ref) {
  final firebaseService = ref.watch(firebaseServiceProvider);
  final authService = ref.watch(authServiceProvider);

  return MangaRepository(
    firebaseService: firebaseService,
    authService: authService,
  );
}

/// Repository for manga data access with Firebase-only persistence
///
/// This repository provides a clean interface for manga and page operations
/// while managing the conversion between Firestore documents and domain models.
class MangaRepository {
  MangaRepository({
    required FirebaseService firebaseService,
    required AuthService authService,
  })  : _firebaseService = firebaseService,
        _authService = authService,
        _deltaCache = DeltaCache();

  final FirebaseService _firebaseService;
  final AuthService _authService;
  final DeltaCache _deltaCache;

  // Track mangaId for each pageId to enable efficient lookups
  final Map<MangaPageId, MangaId> _pageToMangaMap = {};

  // ============================================================================
  // Manga CRUD Operations
  // ============================================================================

  /// Create a new manga project
  /// Returns the manga ID (Firestore document ID)
  /// Throws: AuthException if user not authenticated
  Future<MangaId> createNewManga({String name = '無名の傑作'}) async {
    try {
      final userId = _authService.currentUser?.uid;
      if (userId == null) {
        throw repo_exceptions.AuthException();
      }

      // Create empty delta for ideaMemo and store in cache
      final emptyDelta = Delta();
      _deltaCache.storeDelta(emptyDelta);

      // Create CloudManga with embedded delta
      final cloudManga = CloudManga(
        id: '',
        // Will be generated by Firestore
        userId: userId,
        name: name,
        startPageDirection: MangaStartPage.left.name,
        ideaMemo: {'ops': emptyDelta.toJson()},
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        editLock: null,
      );

      // Upload to Firestore
      final mangaId = await _firebaseService.createManga(cloudManga);
      logger.d('Created new manga: $mangaId');

      return MangaId(mangaId);
    } on FirebaseException catch (e) {
      logger.e('Failed to create manga', error: e);
      throw _handleFirebaseException(e);
    }
  }

  /// Watch a specific manga by ID (reactive)
  /// Returns null if manga doesn't exist or user doesn't have access
  Stream<Manga?> getMangaStream(MangaId id) {
    try {
      return _firebaseService.watchManga(id.id).map((cloudManga) {
        if (cloudManga == null) return null;
        return cloudManga.toManga(_deltaCache);
      });
    } catch (e) {
      logger.e('Error watching manga: $id', error: e);
      rethrow;
    }
  }

  /// Watch all user's manga projects (reactive)
  Stream<List<Manga>> watchAllMangaList() {
    try {
      final userId = _authService.currentUser?.uid;
      if (userId == null) {
        throw repo_exceptions.AuthException();
      }

      return _firebaseService.watchAllMangas(userId).map((cloudMangas) {
        return cloudMangas.map((cm) => cm.toManga(_deltaCache)).toList();
      });
    } catch (e) {
      logger.e('Error watching manga list', error: e);
      rethrow;
    }
  }

  /// Update manga name
  /// Throws: AuthException, NotFoundException, ValidationException
  Future<void> updateMangaName(MangaId id, String name) async {
    try {
      if (name.isEmpty || name.length > 100) {
        throw repo_exceptions.ValidationException(
            'Name must be 1-100 characters');
      }

      final userId = _authService.currentUser?.uid;
      if (userId == null) {
        throw repo_exceptions.AuthException();
      }

      await _firebaseService.updateManga(id.id, {'name': name});
      logger.d('Updated manga name: $id -> $name');
    } on repo_exceptions.ValidationException {
      rethrow;
    } on FirebaseException catch (e) {
      throw _handleFirebaseException(e);
    }
  }

  /// Update manga reading direction
  Future<void> updateStartPage(MangaId id, MangaStartPage value) async {
    try {
      final userId = _authService.currentUser?.uid;
      if (userId == null) {
        throw repo_exceptions.AuthException();
      }

      await _firebaseService.updateManga(id.id, {
        'startPageDirection': value.name,
      });
      logger.d('Updated start page: $id -> ${value.name}');
    } on FirebaseException catch (e) {
      throw _handleFirebaseException(e);
    }
  }

  /// Delete manga and all its pages
  Future<void> deleteManga(MangaId id) async {
    try {
      final userId = _authService.currentUser?.uid;
      if (userId == null) {
        throw repo_exceptions.AuthException();
      }

      // Delete manga (pages will be deleted via cascade or manually)
      await _firebaseService.deleteManga(id.id);

      // Note: Deltas in cache will remain but that's acceptable as they'll be
      // garbage collected when no longer referenced
      logger.d('Deleted manga: $id');
    } on FirebaseException catch (e) {
      throw _handleFirebaseException(e);
    }
  }

  // ============================================================================
  // Delta Management Operations
  // ============================================================================

  /// Save delta to cache and sync to Firestore
  /// Updates the embedded delta in parent manga/page document
  void saveDelta(DeltaId id, Delta delta) {
    _deltaCache.updateDelta(id, delta);

    // TODO: Sync to Firestore
    // This requires tracking which DeltaId belongs to which manga/page
    // For now, this is a placeholder - actual sync will happen through
    // manga/page update methods
    logger.d('Saved delta to cache: $id');
  }

  /// Load delta from cache or Firestore
  Future<Delta?> loadDelta(DeltaId id) async {
    final delta = _deltaCache.getDelta(id);
    if (delta != null) {
      logger.d('Loaded delta from cache: $id');
      return delta;
    }

    // If not in cache, it should have been loaded when the manga/page was loaded
    logger.w('Delta not found in cache: $id');
    return null;
  }

  /// Watch delta changes (reactive)
  Stream<Delta?> getDeltaStream(DeltaId id) {
    return _deltaCache.getDeltaStream(id);
  }

  // ============================================================================
  // MangaPage CRUD Operations
  // ============================================================================

  /// Create a new page in a manga
  /// Automatically assigns next pageIndex
  Future<String> createNewMangaPage(MangaId mangaId) async {
    try {
      final userId = _authService.currentUser?.uid;
      if (userId == null) {
        throw repo_exceptions.AuthException();
      }

      // Get existing pages to determine next page index
      final existingPages = await _firebaseService.fetchMangaPages(mangaId.id);
      final nextPageIndex = existingPages.length;

      // Create empty deltas and store in cache
      final emptyDelta = Delta();
      _deltaCache.storeDelta(emptyDelta);

      // Create CloudMangaPage with embedded deltas
      final cloudPage = CloudMangaPage(
        id: '',
        // Will be generated by Firestore
        mangaId: mangaId.id,
        pageIndex: nextPageIndex,
        memoDelta: {'ops': emptyDelta.toJson()},
        stageDirectionDelta: {'ops': emptyDelta.toJson()},
        dialoguesDelta: {'ops': emptyDelta.toJson()},
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final pageId =
          await _firebaseService.createMangaPage(mangaId.id, cloudPage);

      // Track the mapping for later lookups
      _pageToMangaMap[MangaPageId(pageId)] = mangaId;

      logger.d('Created new manga page: $pageId for manga: $mangaId');

      return pageId;
    } on FirebaseException catch (e) {
      throw _handleFirebaseException(e);
    }
  }

  /// Watch a specific manga page by ID (reactive)
  /// Note: This requires knowing the mangaId - use getMangaPageStreamWithMangaId for better performance
  Stream<MangaPage?> getMangaPageStream(MangaPageId pageId) {
    try {
      // Try to get mangaId from cache
      final mangaId = _pageToMangaMap[pageId];
      if (mangaId != null) {
        return _firebaseService
            .watchMangaPageWithMangaId(mangaId.id, pageId.id)
            .map((cloudPage) {
          if (cloudPage == null) return null;
          return cloudPage.toMangaPage(_deltaCache);
        });
      } else {
        // If we don't have the mangaId cached, we can't efficiently watch the page
        logger.w(
            'MangaId not found for pageId: $pageId. Use getMangaPageStreamWithMangaId instead.');
        return Stream.value(null);
      }
    } catch (e) {
      logger.e('Error watching manga page: $pageId', error: e);
      rethrow;
    }
  }

  /// Watch a specific manga page by ID with mangaId (reactive)
  /// This is more efficient than getMangaPageStream
  Stream<MangaPage?> getMangaPageStreamWithMangaId(
      MangaId mangaId, MangaPageId pageId) {
    try {
      // Update the mapping
      _pageToMangaMap[pageId] = mangaId;

      return _firebaseService
          .watchMangaPageWithMangaId(mangaId.id, pageId.id)
          .map((cloudPage) {
        if (cloudPage == null) return null;
        return cloudPage.toMangaPage(_deltaCache);
      });
    } catch (e) {
      logger.e('Error watching manga page: $pageId', error: e);
      rethrow;
    }
  }

  /// Watch all page IDs for a manga, ordered by pageIndex (reactive)
  Stream<List<MangaPageId>> watchAllMangaPageIdList(MangaId mangaId) {
    try {
      return _firebaseService.watchMangaPages(mangaId.id).map((cloudPages) {
        // Sort by pageIndex
        final sorted = cloudPages.toList()
          ..sort((a, b) => a.pageIndex.compareTo(b.pageIndex));

        // Update the pageToMangaMap for all pages
        for (final page in sorted) {
          _pageToMangaMap[MangaPageId(page.id)] = mangaId;
        }

        return sorted.map((cp) => MangaPageId(cp.id)).toList();
      });
    } catch (e) {
      logger.e('Error watching manga page list: $mangaId', error: e);
      rethrow;
    }
  }

  /// Reorder pages by updating pageIndex
  Future<void> reorderPages(
      MangaId mangaId, List<MangaPageId> pageIdList) async {
    try {
      final userId = _authService.currentUser?.uid;
      if (userId == null) {
        throw repo_exceptions.AuthException();
      }

      if (pageIdList.isEmpty) return;

      // Update pageIndex for each page in batch
      final batch = _firebaseService.batch();
      for (int i = 0; i < pageIdList.length; i++) {
        batch.updatePage(mangaId.id, pageIdList[i].id, {'pageIndex': i});
      }

      await batch.commit();
      logger.d('Reordered ${pageIdList.length} pages for manga: $mangaId');
    } on FirebaseException catch (e) {
      throw _handleFirebaseException(e);
    }
  }

  /// Delete a manga page
  Future<void> deleteMangaPage(MangaPageId pageId) async {
    try {
      final userId = _authService.currentUser?.uid;
      if (userId == null) {
        throw repo_exceptions.AuthException();
      }

      // Get mangaId from cache
      final mangaId = _pageToMangaMap[pageId];
      if (mangaId == null) {
        throw repo_exceptions.NotFoundException('MangaPage', pageId.id);
      }

      await _firebaseService.deleteMangaPage(mangaId.id, pageId.id);

      // Remove from cache
      _pageToMangaMap.remove(pageId);

      logger.d('Deleted manga page: $pageId');
    } on FirebaseException catch (e) {
      throw _handleFirebaseException(e);
    }
  }

  // ============================================================================
  // Sync & Status
  // ============================================================================

  /// Watch sync status for UI indicator
  Stream<SyncStatus> watchSyncStatus() {
    // TODO: Implement actual sync status tracking
    // For now, return a simple stream with online status
    return Stream.value(SyncStatus(
      isOnline: true,
      isSyncing: false,
      lastSyncedAt: DateTime.now(),
      pendingMangaIds: [],
    ));
  }

  /// Force sync all pending changes
  Future<void> forceSyncAll() async {
    // TODO: Implement forced sync
    // Firestore handles sync automatically, so this might be a no-op
    logger.d('Force sync requested (Firestore handles automatically)');
  }

  // ============================================================================
  // Export & Utilities
  // ============================================================================

  /// Export manga to markdown format
  /// TODO: Implement full markdown export functionality
  Future<String> toMarkdown(MangaId mangaId) async {
    try {
      // Fetch manga and pages
      final manga = await _firebaseService.fetchManga(mangaId.id);
      if (manga == null) {
        throw repo_exceptions.NotFoundException('Manga', mangaId.id);
      }

      final pages = await _firebaseService.fetchMangaPages(mangaId.id);

      // Build markdown content
      final buffer = StringBuffer();
      buffer.writeln('# ${manga.name}');
      buffer.writeln();

      // Add idea memo if exists
      if (manga.ideaMemo.isNotEmpty) {
        final ideaMemoOps =
            (manga.ideaMemo['ops'] as List?)?.cast<Map<String, dynamic>>() ??
                [];
        final delta = Delta.fromJson(ideaMemoOps);
        if (delta.isNotEmpty) {
          buffer.writeln('## アイデアメモ');
          buffer.writeln();
          // Extract plain text from delta
          for (final op in delta.toList()) {
            if (op.data is String) {
              buffer.write(op.data);
            }
          }
          buffer.writeln();
          buffer.writeln();
        }
      }

      // Add pages
      for (int i = 0; i < pages.length; i++) {
        final page = pages[i];
        buffer.writeln('## ページ ${i + 1}');
        buffer.writeln();

        // Extract plain text from deltas
        final memoOps =
            (page.memoDelta['ops'] as List?)?.cast<Map<String, dynamic>>() ??
                [];
        final memoDelta = Delta.fromJson(memoOps);
        if (memoDelta.isNotEmpty) {
          buffer.writeln('### メモ');
          for (final op in memoDelta.toList()) {
            if (op.data is String) {
              buffer.write(op.data);
            }
          }
          buffer.writeln();
          buffer.writeln();
        }

        final stageOps = (page.stageDirectionDelta['ops'] as List?)
                ?.cast<Map<String, dynamic>>() ??
            [];
        final stageDelta = Delta.fromJson(stageOps);
        if (stageDelta.isNotEmpty) {
          buffer.writeln('### ト書き');
          for (final op in stageDelta.toList()) {
            if (op.data is String) {
              buffer.write(op.data);
            }
          }
          buffer.writeln();
          buffer.writeln();
        }

        final dialoguesOps = (page.dialoguesDelta['ops'] as List?)
                ?.cast<Map<String, dynamic>>() ??
            [];
        final dialoguesDelta = Delta.fromJson(dialoguesOps);
        if (dialoguesDelta.isNotEmpty) {
          buffer.writeln('### セリフ');
          for (final op in dialoguesDelta.toList()) {
            if (op.data is String) {
              buffer.write(op.data);
            }
          }
          buffer.writeln();
          buffer.writeln();
        }
      }

      return buffer.toString();
    } catch (e) {
      logger.e('Failed to export manga to markdown', error: e);
      rethrow;
    }
  }

  // ============================================================================
  // Error Handling
  // ============================================================================

  Exception _handleFirebaseException(FirebaseException e) {
    if (e.code == 'permission-denied') {
      return repo_exceptions.PermissionException();
    } else if (e.code == 'not-found') {
      return repo_exceptions.NotFoundException('Resource', 'unknown');
    } else if (e.code == 'unauthenticated') {
      return repo_exceptions.AuthException();
    } else {
      return repo_exceptions.StorageException(e.message ?? 'Storage error',
          code: e.code);
    }
  }

  /// Dispose resources
  void dispose() {
    _deltaCache.dispose();
  }
}

// ============================================================================
// Conversion Extensions
// ============================================================================

/// Extension for converting CloudManga to Manga
extension CloudMangaConversion on CloudManga {
  Manga toManga(DeltaCache cache) {
    // Convert embedded Delta map to DeltaId
    final ideaMemoOps =
        (ideaMemo['ops'] as List?)?.cast<Map<String, dynamic>>() ?? [];
    final delta = Delta.fromJson(ideaMemoOps);
    final deltaId = cache.storeDelta(delta);

    return Manga(
      id: MangaId(id),
      name: name,
      startPage: MangaStartPageExt.fromString(startPageDirection),
      ideaMemo: deltaId,
    );
  }
}

/// Extension for converting Manga to CloudManga
extension MangaToCloudConversion on Manga {
  CloudManga toCloudManga(String userId, DeltaCache cache) {
    // Convert DeltaId to embedded Delta map
    final delta = cache.getDelta(ideaMemo);
    if (delta == null) {
      throw Exception('Delta not found in cache for DeltaId: $ideaMemo');
    }

    return CloudManga(
      id: id.id,
      userId: userId,
      name: name,
      startPageDirection: startPage.name,
      ideaMemo: {'ops': delta.toJson()},
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      editLock: null,
    );
  }
}

/// Extension for converting CloudMangaPage to MangaPage
extension CloudMangaPageConversion on CloudMangaPage {
  MangaPage toMangaPage(DeltaCache cache) {
    // Convert embedded Delta maps to DeltaIds
    final memoOps =
        (memoDelta['ops'] as List?)?.cast<Map<String, dynamic>>() ?? [];
    final memoDeltaObj = Delta.fromJson(memoOps);
    final memoDeltaId = cache.storeDelta(memoDeltaObj);

    final stageOps =
        (stageDirectionDelta['ops'] as List?)?.cast<Map<String, dynamic>>() ??
            [];
    final stageDeltaObj = Delta.fromJson(stageOps);
    final stageDeltaId = cache.storeDelta(stageDeltaObj);

    final dialoguesOps =
        (dialoguesDelta['ops'] as List?)?.cast<Map<String, dynamic>>() ?? [];
    final dialoguesDeltaObj = Delta.fromJson(dialoguesOps);
    final dialoguesDeltaId = cache.storeDelta(dialoguesDeltaObj);

    return MangaPage(
      id: MangaPageId(id),
      memoDelta: memoDeltaId,
      stageDirectionDelta: stageDeltaId,
      dialoguesDelta: dialoguesDeltaId,
    );
  }
}

/// Extension for converting MangaPage to CloudMangaPage
extension MangaPageToCloudConversion on MangaPage {
  CloudMangaPage toCloudMangaPage(
      String mangaId, int pageIndex, DeltaCache cache) {
    // Convert DeltaIds to embedded Delta maps
    final memoDeltaObj = cache.getDelta(memoDelta);
    final stageDeltaObj = cache.getDelta(stageDirectionDelta);
    final dialoguesDeltaObj = cache.getDelta(dialoguesDelta);

    if (memoDeltaObj == null ||
        stageDeltaObj == null ||
        dialoguesDeltaObj == null) {
      throw Exception('One or more deltas not found in cache');
    }

    return CloudMangaPage(
      id: id.id,
      mangaId: mangaId,
      pageIndex: pageIndex,
      memoDelta: {'ops': memoDeltaObj.toJson()},
      stageDirectionDelta: {'ops': stageDeltaObj.toJson()},
      dialoguesDelta: {'ops': dialoguesDeltaObj.toJson()},
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );
  }
}
